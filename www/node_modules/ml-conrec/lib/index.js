"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Conrec = void 0;
const BasicContourDrawer_1 = require("./BasicContourDrawer");
const ShapeContourDrawer_1 = require("./ShapeContourDrawer");
const calculateContour_1 = require("./calculateContour");
class Conrec {
    constructor(matrix, options = {}) {
        const { swapAxes = false } = options;
        this.matrix = matrix;
        this.rows = matrix.length;
        this.columns = matrix[0].length;
        if (swapAxes) {
            // We swap axes, which means xs are in the rows direction. This is the normal
            // way for the conrec library.
            this.xs = options.xs || range(0, this.rows, 1);
            this.ys = options.ys || range(0, this.columns, 1);
        }
        else {
            // We do not swap axes, so if the user provided xs or ys, we must swap the
            // internal values so the algorithm can still work.
            this.xs = options.ys || range(0, this.rows, 1);
            this.ys = options.xs || range(0, this.columns, 1);
        }
        this.swapAxes = swapAxes;
        this.hasMinMax = false;
        this.min = 0;
        this.max = 0;
    }
    drawContour(options) {
        const { nbLevels = 10, timeout = 0, contourDrawer = 'basic' } = options;
        let levels;
        if (options.levels) {
            levels = [...options.levels];
        }
        else {
            this._computeMinMax();
            const interval = (this.max - this.min) / (nbLevels - 1);
            levels = range(this.min, this.max + interval, interval);
        }
        levels.sort((a, b) => a - b);
        let contourDrawerInstance;
        if (typeof contourDrawer === 'string') {
            if (contourDrawer === 'basic') {
                contourDrawerInstance = new BasicContourDrawer_1.BasicContourDrawer(levels, this.swapAxes);
            }
            else if (contourDrawer === 'shape') {
                contourDrawerInstance = new ShapeContourDrawer_1.ShapeContourDrawer(levels, this.swapAxes);
            }
            else {
                throw new Error(`invalid contour drawer: ${String(contourDrawer)}`);
            }
        }
        else {
            throw new TypeError('contourDrawer must be a string');
        }
        const isTimeout = (0, calculateContour_1.calculateContour)(this.matrix, this.xs, this.ys, levels, contourDrawerInstance, {
            timeout,
        });
        return {
            contours: contourDrawerInstance.getContour(),
            timeout: isTimeout,
        };
    }
    _computeMinMax() {
        if (!this.hasMinMax) {
            const r = minMax(this.matrix);
            this.min = r.min;
            this.max = r.max;
            this.hasMinMax = true;
        }
    }
}
exports.Conrec = Conrec;
function range(from, to, step) {
    const result = [];
    for (let i = from; i < to; i += step) {
        result.push(i);
    }
    return result;
}
function minMax(matrix) {
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    for (const row of matrix) {
        for (const val of row) {
            if (val < min)
                min = val;
            if (val > max)
                max = val;
        }
    }
    return {
        min,
        max,
    };
}
//# sourceMappingURL=index.js.map