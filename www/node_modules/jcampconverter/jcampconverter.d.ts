import { Logger } from 'cheminfo-types';
import type { Molecule } from 'openchemlib';
import { openchemlib } from 'openchemlib';

declare interface Add2DOptions extends GenerateContourLinesOptions {
    /**
     * Don't calculate contour in case of 2D.
     */
    noContour?: boolean;
}

declare interface Chromatogram {
    times: number[];
    series: Record<string, {
        dimension: number;
        data: any[];
    }>;
}

declare interface ContourLines {
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
    segments: Array<{
        zValue?: number;
        lines?: number[];
    }>;
}

/**
 * Parse JCAMP-DX data.
 * The data can be provided as a string or array buffer. In this latter case
 * we will convert it first to a string before parsing.
 * @param jcamp
 * @param optionsParam
 * @returns Converted result.
 */
export declare function convert(jcamp: string | ArrayBuffer | Uint8Array, optionsParam?: ConvertOptions): ConvertResult;

/**
 * Conversion options.
 */
declare interface ConvertOptions extends Partial<Add2DOptions> {
    /**
     * If it is true, anywhere out of XYDATA, PEAKTABLE n PEAKASSIGNMENTS the comments are removed
     * @default false
     */
    removeComments?: boolean;
    /**
     * By default we don't keep meta information.
     * @default `/^$/`
     */
    keepRecordsRegExp?: RegExp;
    /**
     * Canonize the Labels (uppercase without symbol).
     */
    canonicDataLabels?: boolean;
    /**
     * Canonize the metadata Labels (uppercase without symbol).
     */
    canonicMetadataLabels?: boolean;
    /**
     * Convert numbers to Number.
     */
    dynamicTyping?: boolean;
    /**
     * Remove the XY data.
     */
    withoutXY?: boolean;
    /**
     * Special post-processing for GC / HPLC / MS.
     */
    chromatogram?: boolean;
    /**
     * Force to keep the spectra in case of 2D.
     */
    keepSpectra?: boolean;
    /**
     * For which fields we should not trim ?
     * @default `/^$/`
     */
    noTrimRegExp?: RegExp;
    /**
     * A logger like `pino`.
     */
    logger?: Logger;
    /**
     * Add profiling information.
     */
    wantXY?: boolean;
    start?: number;
    fastParse?: boolean;
}

declare interface ConvertResult {
    entries: Entry[];
    flatten: Entry[];
}

/**
 * Parse the JCAMP-DX to extract the structure as a tree.
 * @param jcamp
 * @param options
 * @returns Tree.
 */
export declare function createTree(jcamp: string | ArrayBuffer | Uint8Array, options?: CreateTreeOptions): Stack[];

declare interface CreateTreeOptions {
    flatten?: boolean;
}

declare interface Entry {
    spectra: Spectrum[];
    ntuples: Ntuples;
    meta: Record<string, string | string[] | number | number[] | boolean | boolean[] | undefined>;
    info: Record<string, string | string[] | number | number[] | boolean | boolean[] | undefined>;
    tmp: Record<string, string | string[] | number | number[] | boolean | boolean[] | undefined>;
    title?: string;
    dataType?: string;
    dataClass?: string;
    jcampDX?: string;
    jcampCS?: string;
    twoD?: boolean;
    minMax?: MinMax;
    children?: Entry[];
    shiftOffsetVal?: number;
    shiftOffsetNum?: number;
    xType?: string;
    yType?: string;
    chromatogram?: Chromatogram;
    contourLines?: ContourLines;
}

declare interface GenerateContourLinesOptions {
    /**
     * Number of positive / negative contour levels to calculate.
     * @default `7`
     */
    nbContourLevels: number;
    /**
     * Define for 2D the level as 5 times the median as default.
     * @default `5`
     */
    noiseMultiplier: number;
}

declare interface MinMax {
    z: number[][];
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
    minZ: number;
    maxZ: number;
    median?: number;
    noice?: number;
}

declare interface Ntuples {
    varname?: string[];
    symbol?: string[];
    vartype?: string[];
    varform?: string[];
    vardim?: number[];
    units?: string[];
    factor?: number[];
    first?: number[];
    last?: number[];
    min?: number[];
    max?: number[];
    nucleus?: string[];
    [key: string]: any | undefined;
}

declare type OCL = openchemlib;

declare interface ParsedCS {
    molfile: string;
    molecule: Molecule;
}

/**
 *
 * @param entry
 * @param options
 * @returns ParsedCS
 */
export declare function parseJcampCS(entry: Entry, options: ParseJcampCSOptions): ParsedCS | undefined;

declare interface ParseJcampCSOptions {
    OCL: OCL;
    logger?: Logger;
}

declare interface Spectrum {
    [key: string]: any;
    data: Record<string, number[]>;
    firstX?: number;
    firstY?: number;
    lastX?: number;
    deltaX?: number;
    yFactor?: number;
    xFactor?: number;
    nbPoints?: number;
}

declare interface Stack {
    title: string;
    jcamp: string;
    children: Stack[] | undefined;
    jcampDX?: string;
    jcampCS?: string;
    dataType?: string;
    dataClass?: string;
}

export { }
